import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import Papa from 'papaparse';
import { saveAs } from 'file-saver';
import { Menu, MenuCategory, MenuItem } from '../types/menu';
import { formatPrice, getCurrencySymbol } from './currency';

export type ExportFormat = 'pdf' | 'json' | 'csv' | 'xlsx';

export interface ExportOptions {
  format: ExportFormat;
  includeImages: boolean;
  includeDescriptions: boolean;
  includePricing: boolean;
  includeIngredients: boolean;
  includeAllergens: boolean;
  includeNutrition: boolean;
  includeDietaryTags: boolean;
  categorySeparation: boolean;
}

export const defaultExportOptions: ExportOptions = {
  format: 'pdf',
  includeImages: false,
  includeDescriptions: true,
  includePricing: true,
  includeIngredients: true,
  includeAllergens: true,
  includeNutrition: true,
  includeDietaryTags: true,
  categorySeparation: true,
};

/**
 * Export menu to PDF format
 */
export const exportToPDF = async (menu: Menu, options: ExportOptions): Promise<void> => {
  try {
    const pdf = new jsPDF();
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    let yPosition = margin;

    // Color palette for attractive design
    const colors = {
      primary: '#dc2626',
      secondary: '#f97316',
      accent: '#059669',
      text: '#111827',
      lightText: '#6b7280',
      background: '#f9fafb',
      border: '#e5e7eb'
    };

    // Helper function to add text with word wrapping
    const addText = (text: string, x: number, y: number, maxWidth: number, fontSize = 12, color = colors.text): number => {
      pdf.setFontSize(fontSize);
      pdf.setTextColor(color);
      const lines = pdf.splitTextToSize(text, maxWidth);
      pdf.text(lines, x, y);
      return y + (lines.length * fontSize * 0.35);
    };

    // Helper function to add colored rectangle
    const addRect = (x: number, y: number, width: number, height: number, color: string, fill = true) => {
      pdf.setFillColor(color);
      if (fill) {
        pdf.rect(x, y, width, height, 'F');
      } else {
        pdf.setDrawColor(color);
        pdf.rect(x, y, width, height, 'S');
      }
    };

    // Helper function to check if we need a new page
    const checkNewPage = (requiredHeight: number): number => {
      if (yPosition + requiredHeight > pageHeight - margin - 30) { // Leave space for footer
        addPageFooter();
        pdf.addPage();
        addPageHeader();
        return margin + 40; // Account for header space
      }
      return yPosition;
    };

    // Add page header
    const addPageHeader = () => {
      // Header background
      addRect(0, 0, pageWidth, 35, colors.primary);
      
      // Restaurant name in header
      pdf.setTextColor('#ffffff');
      pdf.setFontSize(16);
      pdf.setFont('helvetica', 'bold');
      pdf.text(menu.restaurant?.name || menu.name, margin, 22);
      
      // Export date in header
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      const exportDate = new Date().toLocaleDateString('en-IN', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      pdf.text(`Exported on ${exportDate}`, pageWidth - margin - 60, 22);
    };

    // Add page footer
    const addPageFooter = () => {
      const currentPage = (pdf as any).internal.getCurrentPageInfo().pageNumber;
      
      // Footer line
      pdf.setDrawColor(colors.border);
      pdf.line(margin, pageHeight - 20, pageWidth - margin, pageHeight - 20);
      
      // Footer text
      pdf.setTextColor(colors.lightText);
      pdf.setFontSize(8);
      pdf.setFont('helvetica', 'normal');
      pdf.text('Generated by Smart Dine - Digital Menu Solution', margin, pageHeight - 12);
      pdf.text(`Page ${currentPage}`, pageWidth - margin - 15, pageHeight - 12);
    };

    // Create attractive cover page
    const createCoverPage = () => {
      // Background design with simple rectangles
      addRect(0, 0, pageWidth, 60, colors.primary);
      addRect(0, pageHeight - 60, pageWidth, 60, colors.secondary);
      
      // Main title on white background
      pdf.setTextColor('#ffffff');
      pdf.setFontSize(28);
      pdf.setFont('helvetica', 'bold');
      const restaurantName = menu.restaurant?.name || menu.name;
      const titleWidth = pdf.getTextWidth(restaurantName);
      pdf.text(restaurantName, (pageWidth - titleWidth) / 2, 35);
      
      // Restaurant name again in main area
      pdf.setTextColor(colors.primary);
      pdf.setFontSize(32);
      pdf.text(restaurantName, (pageWidth - pdf.getTextWidth(restaurantName)) / 2, 100);
      
      // Subtitle
      pdf.setTextColor(colors.text);
      pdf.setFontSize(16);
      pdf.setFont('helvetica', 'normal');
      pdf.text('DIGITAL MENU', pageWidth / 2, 120, { align: 'center' });
      
      // Decorative elements
      pdf.setDrawColor(colors.secondary);
      pdf.setLineWidth(2);
      pdf.line(pageWidth / 2 - 40, 130, pageWidth / 2 + 40, 130);
      
      // Menu stats in an attractive box
      const statsY = 140;
      const statsBoxHeight = 60;
      addRect(margin + 20, statsY, pageWidth - 2 * margin - 40, statsBoxHeight, colors.background);
      addRect(margin + 20, statsY, pageWidth - 2 * margin - 40, statsBoxHeight, colors.primary, false);
      
      const totalItems = menu.categories.reduce((total, cat) => total + (cat.items?.filter(item => item.isAvailable).length || 0), 0);
      const totalCategories = menu.categories.filter(cat => cat.isActive).length;
      
      pdf.setTextColor(colors.text);
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('MENU OVERVIEW', pageWidth / 2, statsY + 20, { align: 'center' });
      
      pdf.setFontSize(12);
      pdf.setFont('helvetica', 'normal');
      pdf.text(`${totalCategories} Categories • ${totalItems} Available Items`, pageWidth / 2, statsY + 35, { align: 'center' });
      
      if (menu.restaurant?.cuisine && menu.restaurant.cuisine.length > 0) {
        pdf.setTextColor(colors.secondary);
        pdf.setFontSize(11);
        pdf.text(`Cuisine: ${menu.restaurant.cuisine.join(', ')}`, pageWidth / 2, statsY + 50, { align: 'center' });
      }
      
      // Export information
      const exportDate = new Date();
      const formattedDate = exportDate.toLocaleDateString('en-IN', {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      });
      const formattedTime = exportDate.toLocaleTimeString('en-IN', {
        hour: '2-digit',
        minute: '2-digit'
      });
      
      pdf.setTextColor(colors.lightText);
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      pdf.text(`Exported on ${formattedDate} at ${formattedTime}`, pageWidth / 2, 230, { align: 'center' });
      
      // Bottom branding
      pdf.setTextColor(colors.primary);
      pdf.setFontSize(12);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Smart Dine', pageWidth / 2, pageHeight - 40, { align: 'center' });
      
      pdf.setTextColor(colors.lightText);
      pdf.setFontSize(9);
      pdf.setFont('helvetica', 'normal');
      pdf.text('Digital Menu Solution', pageWidth / 2, pageHeight - 28, { align: 'center' });
      
      // Add next page for menu content
      pdf.addPage();
    };
    
    // Create cover page
    createCoverPage();

    // Add header to menu content pages
    addPageHeader();
    yPosition = margin + 50;

    // Section divider
    addRect(margin, yPosition, pageWidth - 2 * margin, 2, colors.primary);
    yPosition += 15;

    // Restaurant info section with better styling
    if (menu.restaurant) {
      // Info box background
      addRect(margin, yPosition, pageWidth - 2 * margin, 60, colors.background);
      addRect(margin, yPosition, pageWidth - 2 * margin, 60, colors.border, false);
      
      let infoY = yPosition + 10;
      
      if (menu.restaurant.description) {
        pdf.setTextColor(colors.text);
        pdf.setFontSize(12);
        pdf.setFont('helvetica', 'normal');
        infoY = addText(menu.restaurant.description, margin + 10, infoY, pageWidth - 2 * margin - 20, 12, colors.text) + 3;
      }

      if (menu.restaurant.address) {
        const address = `${menu.restaurant.address.street || ''}, ${menu.restaurant.address.city || ''}, ${menu.restaurant.address.state || ''} ${menu.restaurant.address.zipCode || ''}`.trim();
        if (address !== ', ,') {
          pdf.setFontSize(10);
          pdf.setFont('helvetica', 'normal');
          infoY = addText(`📍 ${address}`, margin + 10, infoY, pageWidth - 2 * margin - 20, 10, colors.lightText) + 2;
        }
      }

      if (menu.restaurant.contact?.phone) {
        pdf.setFontSize(10);
        infoY = addText(`📞 ${menu.restaurant.contact.phone}`, margin + 10, infoY, pageWidth - 2 * margin - 20, 10, colors.lightText) + 2;
      }

      if (menu.restaurant.cuisine && menu.restaurant.cuisine.length > 0) {
        pdf.setFontSize(10);
        infoY = addText(`🍽️ ${menu.restaurant.cuisine.join(', ')}`, margin + 10, infoY, pageWidth - 2 * margin - 20, 10, colors.accent);
      }
      
      yPosition += 70;
    }

    // Menu categories and items with enhanced styling
    for (const category of menu.categories) {
      if (!category.isActive) continue;

      yPosition = checkNewPage(40);
      
      // Category header with background
      const categoryHeaderHeight = 25;
      addRect(margin, yPosition, pageWidth - 2 * margin, categoryHeaderHeight, colors.secondary);
      
      // Category title
      pdf.setTextColor('#ffffff');
      pdf.setFontSize(16);
      pdf.setFont('helvetica', 'bold');
      pdf.text(category.name.toUpperCase(), margin + 10, yPosition + 16);
      
      // Item count
      const availableItems = (category.items || []).filter(item => item.isAvailable);
      pdf.setFontSize(10);
      pdf.text(`${availableItems.length} items`, pageWidth - margin - 40, yPosition + 16);
      
      yPosition += categoryHeaderHeight + 5;

      if (options.includeDescriptions && category.description) {
        pdf.setTextColor(colors.lightText);
        pdf.setFontSize(10);
        pdf.setFont('helvetica', 'italic');
        yPosition = addText(category.description, margin + 5, yPosition, pageWidth - 2 * margin - 10, 10, colors.lightText) + 5;
      }
      // Menu items with card-like styling
      for (const item of availableItems) {
        yPosition = checkNewPage(70);

        // Item card background
        const itemHeight = 50;
        addRect(margin + 5, yPosition, pageWidth - 2 * margin - 10, itemHeight, colors.background);
        addRect(margin + 5, yPosition, pageWidth - 2 * margin - 10, itemHeight, colors.border, false);
        
        // Left accent line
        addRect(margin + 5, yPosition, 3, itemHeight, colors.primary);
        
        let itemY = yPosition + 12;
        const itemLeftMargin = margin + 15;
        const itemRightMargin = pageWidth - margin - 15;

        // Item name with styling
        pdf.setTextColor(colors.text);
        pdf.setFontSize(13);
        pdf.setFont('helvetica', 'bold');
        const itemNameWidth = options.includePricing ? pageWidth - 2 * margin - 80 : pageWidth - 2 * margin - 30;
        pdf.text(item.name, itemLeftMargin, itemY);
        
        // Popular/Featured badges
        if (item.isPopular || item.isFeatured) {
          let badgeX = itemLeftMargin + pdf.getTextWidth(item.name) + 10;
          if (item.isPopular) {
            pdf.setFontSize(8);
            pdf.setTextColor(colors.accent);
            pdf.setFont('helvetica', 'bold');
            pdf.text('★ POPULAR', badgeX, itemY);
            badgeX += 35;
          }
          if (item.isFeatured) {
            pdf.setFontSize(8);
            pdf.setTextColor(colors.secondary);
            pdf.setFont('helvetica', 'bold');
            pdf.text('◆ FEATURED', badgeX, itemY);
          }
        }

        // Price styling
        if (options.includePricing) {
          pdf.setTextColor(colors.primary);
          pdf.setFontSize(14);
          pdf.setFont('helvetica', 'bold');
          pdf.text(formatPrice(item.price), itemRightMargin, itemY, { align: 'right' });
          
          if (item.originalPrice && item.originalPrice > item.price) {
            pdf.setTextColor(colors.lightText);
            pdf.setFontSize(9);
            pdf.setFont('helvetica', 'normal');
            const strikeThrough = formatPrice(item.originalPrice);
            pdf.text(strikeThrough, itemRightMargin, itemY - 10, { align: 'right' });
            // Add strikethrough line
            const priceWidth = pdf.getTextWidth(strikeThrough);
            pdf.line(itemRightMargin - priceWidth, itemY - 10, itemRightMargin, itemY - 10);
          }
        }

        itemY += 8;

        // Description
        if (options.includeDescriptions && item.description) {
          pdf.setTextColor(colors.lightText);
          pdf.setFontSize(10);
          pdf.setFont('helvetica', 'normal');
          const descLines = pdf.splitTextToSize(item.description, pageWidth - 2 * margin - 40);
          pdf.text(descLines, itemLeftMargin, itemY);
          itemY += descLines.length * 3.5;
        }

        // Additional details in a compact row
        const details = [];
        
        // Nutrition info
        if (options.includeNutrition) {
          if (item.calories) details.push(`⚡ ${item.calories} cal`);
          if (item.preparationTime) details.push(`⏱️ ${item.preparationTime} min`);
          if (item.spicyLevel && item.spicyLevel > 0) {
            const spiceText = '🌶️'.repeat(item.spicyLevel);
            details.push(`${spiceText}`);
          }
        }
        
        // Dietary tags as emojis/icons
        if (options.includeDietaryTags && item.dietaryTags && item.dietaryTags.length > 0) {
          const tagEmojis = item.dietaryTags.map(tag => {
            const tagName = typeof tag === 'string' ? tag : tag.name;
            switch(tagName?.toLowerCase()) {
              case 'vegetarian': return '🥬';
              case 'vegan': return '🌱';
              case 'gluten-free': return '🌾🚫';
              case 'dairy-free': return '🥛🚫';
              case 'keto': return '🥑';
              case 'spicy': return '🌶️';
              default: return tagName?.charAt(0).toUpperCase() || '';
            }
          }).filter(Boolean);
          if (tagEmojis.length > 0) {
            details.push(tagEmojis.join(' '));
          }
        }
        
        if (details.length > 0) {
          pdf.setTextColor(colors.lightText);
          pdf.setFontSize(8);
          pdf.setFont('helvetica', 'normal');
          pdf.text(details.join(' • '), itemLeftMargin, itemY);
          itemY += 6;
        }
        
        // Ingredients (if enabled and space allows)
        if (options.includeIngredients && item.ingredients && item.ingredients.length > 0) {
          pdf.setTextColor(colors.lightText);
          pdf.setFontSize(8);
          pdf.setFont('helvetica', 'italic');
          const ingredients = `Ingredients: ${item.ingredients.slice(0, 6).join(', ')}${item.ingredients.length > 6 ? '...' : ''}`;
          const ingredientLines = pdf.splitTextToSize(ingredients, pageWidth - 2 * margin - 40);
          pdf.text(ingredientLines, itemLeftMargin, itemY);
          itemY += ingredientLines.length * 2.5;
        }
        
        // Allergens (if any)
        if (options.includeAllergens && item.allergens && item.allergens.length > 0) {
          pdf.setTextColor('#dc2626'); // Red for allergens
          pdf.setFontSize(8);
          pdf.setFont('helvetica', 'bold');
          pdf.text(`⚠️ Contains: ${item.allergens.join(', ')}`, itemLeftMargin, itemY);
        }

        yPosition += itemHeight + 10; // Space between item cards
      }

      if (options.categorySeparation) {
        yPosition += 15; // Extra space between categories
        // Add decorative separator
        pdf.setDrawColor(colors.border);
        pdf.line(margin + 20, yPosition - 8, pageWidth - margin - 20, yPosition - 8);
      }
    }

    // Add final footer to last page
    addPageFooter();
    
    // Add footer to all pages
    const pageCount = (pdf as any).internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      pdf.setPage(i);
      
      // Page number in footer (already added by addPageFooter, but ensure consistency)
      if (i === pageCount) {
        // Add a special note on the last page
        pdf.setTextColor(colors.lightText);
        pdf.setFontSize(8);
        pdf.setFont('helvetica', 'italic');
        const exportInfo = `Menu exported with ${menu.categories.length} categories and ${menu.categories.reduce((total, cat) => total + (cat.items?.length || 0), 0)} items`;
        pdf.text(exportInfo, pageWidth / 2, pageHeight - 25, { align: 'center' });
      }
    }

    // Save PDF
    const fileName = `${(menu.restaurant?.name || menu.name).replace(/[^a-zA-Z0-9]/g, '_')}_menu.pdf`;
    pdf.save(fileName);
  } catch (error) {
    console.error('Error generating PDF:', error);
    throw new Error('Failed to generate PDF');
  }
};

/**
 * Export menu to CSV format
 */
export const exportToCSV = async (menu: Menu, options: ExportOptions): Promise<void> => {
  try {
    const csvData: any[] = [];

    // Header row
    const headers = ['Category', 'Item Name'];
    if (options.includeDescriptions) headers.push('Description');
    if (options.includePricing) headers.push('Price', 'Original Price');
    if (options.includeIngredients) headers.push('Ingredients');
    if (options.includeAllergens) headers.push('Allergens');
    if (options.includeDietaryTags) headers.push('Dietary Tags');
    if (options.includeNutrition) headers.push('Calories', 'Prep Time (min)', 'Spicy Level');
    headers.push('Available');

    for (const category of menu.categories) {
      if (!category.isActive) continue;

      const items = category.items || [];
      for (const item of items) {
        const row: any = {
          'Category': category.name,
          'Item Name': item.name,
        };

        if (options.includeDescriptions) {
          row['Description'] = item.description || '';
        }

        if (options.includePricing) {
          row['Price'] = formatPrice(item.price);
          row['Original Price'] = item.originalPrice ? formatPrice(item.originalPrice) : '';
        }

        if (options.includeIngredients) {
          row['Ingredients'] = item.ingredients ? item.ingredients.join(', ') : '';
        }

        if (options.includeAllergens) {
          row['Allergens'] = item.allergens ? item.allergens.join(', ') : '';
        }

        if (options.includeDietaryTags) {
          row['Dietary Tags'] = item.dietaryTags ? 
            item.dietaryTags.map(tag => typeof tag === 'string' ? tag : tag.name).join(', ') : '';
        }

        if (options.includeNutrition) {
          row['Calories'] = item.calories || '';
          row['Prep Time (min)'] = item.preparationTime || '';
          row['Spicy Level'] = item.spicyLevel || 0;
        }

        row['Available'] = item.isAvailable ? 'Yes' : 'No';

        csvData.push(row);
      }
    }

    const csv = Papa.unparse(csvData);
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const fileName = `${(menu.restaurant?.name || menu.name).replace(/[^a-zA-Z0-9]/g, '_')}_menu.csv`;
    saveAs(blob, fileName);
  } catch (error) {
    console.error('Error generating CSV:', error);
    throw new Error('Failed to generate CSV');
  }
};

/**
 * Export menu to JSON format
 */
export const exportToJSON = async (menu: Menu, options: ExportOptions): Promise<void> => {
  try {
    const exportData = {
      restaurant: {
        name: menu.restaurant?.name || menu.name,
        description: menu.restaurant?.description,
        address: menu.restaurant?.address,
        contact: menu.restaurant?.contact,
        cuisine: menu.restaurant?.cuisine,
      },
      menu: {
        name: menu.name,
        description: menu.description,
        currency: menu.settings?.currency || 'INR',
      },
      categories: menu.categories
        .filter(category => category.isActive)
        .map(category => ({
          name: category.name,
          description: options.includeDescriptions ? category.description : undefined,
          items: (category.items || [])
            .filter(item => item.isAvailable)
            .map(item => {
              const exportItem: any = {
                name: item.name,
                price: item.price,
                priceFormatted: formatPrice(item.price),
                available: item.isAvailable,
              };

              if (options.includeDescriptions && item.description) {
                exportItem.description = item.description;
              }

              if (options.includePricing && item.originalPrice) {
                exportItem.originalPrice = item.originalPrice;
                exportItem.originalPriceFormatted = formatPrice(item.originalPrice);
              }

              if (options.includeImages && item.image) {
                exportItem.image = item.image;
              }

              if (options.includeIngredients && item.ingredients) {
                exportItem.ingredients = item.ingredients;
              }

              if (options.includeAllergens && item.allergens) {
                exportItem.allergens = item.allergens;
              }

              if (options.includeDietaryTags && item.dietaryTags) {
                exportItem.dietaryTags = item.dietaryTags.map(tag => 
                  typeof tag === 'string' ? tag : { id: tag.id, name: tag.name, icon: tag.icon }
                );
              }

              if (options.includeNutrition) {
                if (item.calories) exportItem.calories = item.calories;
                if (item.preparationTime) exportItem.preparationTime = item.preparationTime;
                if (item.spicyLevel) exportItem.spicyLevel = item.spicyLevel;
              }

              return exportItem;
            })
        })),
      exportedAt: new Date().toISOString(),
      exportOptions: options,
    };

    const json = JSON.stringify(exportData, null, 2);
    const blob = new Blob([json], { type: 'application/json;charset=utf-8;' });
    const fileName = `${(menu.restaurant?.name || menu.name).replace(/[^a-zA-Z0-9]/g, '_')}_menu.json`;
    saveAs(blob, fileName);
  } catch (error) {
    console.error('Error generating JSON:', error);
    throw new Error('Failed to generate JSON');
  }
};

/**
 * Main export function that delegates to specific format handlers
 */
export const exportMenu = async (menu: Menu, options: ExportOptions): Promise<void> => {
  switch (options.format) {
    case 'pdf':
      return exportToPDF(menu, options);
    case 'csv':
      return exportToCSV(menu, options);
    case 'json':
      return exportToJSON(menu, options);
    default:
      throw new Error(`Unsupported export format: ${options.format}`);
  }
};

/**
 * Get export format details
 */
export const getExportFormats = () => [
  {
    id: 'pdf',
    name: 'PDF Document',
    description: 'Professional PDF document with formatted layout',
    icon: '📄',
    recommended: true,
  },
  {
    id: 'csv',
    name: 'CSV Spreadsheet',
    description: 'Comma-separated values for spreadsheet applications',
    icon: '📊',
    recommended: false,
  },
  {
    id: 'json',
    name: 'JSON Data',
    description: 'Structured data format for developers',
    icon: '🔧',
    recommended: false,
  },
];